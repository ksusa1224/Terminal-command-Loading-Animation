<!DOCTYPE html>
<html>
<!--
Copyright (c) Necotech.org 2014, All rights reserved.
-->
<head>
	<title>Cat 3D Model</title>
	<style type="text/css">
		body {
		}

		#msg {
			color: gray;
			user-select: none;
		}
	</style>
	<script type="text/javascript" th:src="@{js/glMatrix-0.9.5.min.js}"></script>
	<script type="text/javascript" th:src="@{js/_main.js}"></script>
	<script type="text/javascript" th:src="@{js/model.js}"></script>
</head>

<body>
	<div id="msg">0 fps</div>
	<canvas id="glcanvas" width="640" height="480">
		該当ブラウザはHTML5のCanvasをサポートしていません。
	</canvas>
	<div>マウスでドラッグすると回転できます</div>

	<script id="shader-vs" type="x-shader/x-vertex">
		attribute vec3 aVertexPosition;  // modelファイルからの頂点データ
		attribute vec3 aVertexNormal;    // modelファイルからの法線データ

		uniform mat4 uNormalMatrix;      // 法線変換行列
		uniform mat4 uMVMatrix;          // 共通オブジェクト変換行列
		uniform mat4 uPMatrix;           // 共通投影変換行列
		uniform vec4 ambientLight;       // オブジェクトの環境反射色
		varying vec4 vLighting;          // 計算されたライティングの色

		void main(void) {
			// 現在処理中の頂点位置を行列によって変換処理を行う
			gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);

			// 光源の色(RGB)
			vec3 directionalLightColor = vec3(0.5, 0.5, 0.5);
			// 光源の位置（手前右側）
			vec3 directionalVector = vec3(0.85, 0.8, 0.75);
			// オブジェクト法線の変換
			vec4 transformedNormal = uNormalMatrix * vec4(aVertexNormal, 1.0);
			// 光源と変換した法線の内積　（つまり頂点法線が光源に向くほど、明るくなる）
			float directional = max(dot(transformedNormal.xyz, directionalVector), 0.0);

			// 内積を乗って光の色とオブジェクトの環境反射色を足して、最終の色を計算する
			// vLighting に保存した色はフラグメントシェーダに自動的に渡される
			vLighting = vec4(ambientLight.rgb + (directionalLightColor * directional), 1.0);
		}
	</script>

	<script id="shader-fs" type="x-shader/x-fragment">
		varying mediump vec4 vLighting;

		void main(void) {
			gl_FragColor = vLighting;
		}
	</script>

	<script type="text/javascript">
		// 共通シェーダ初期化処理

		function initShaders() {

			var fragmentShader = getShader(gl, "shader-fs");
			var vertexShader = getShader(gl, "shader-vs");

			// Create the shader program
			shaderProgram = gl.createProgram();
			gl.attachShader(shaderProgram, vertexShader);
			gl.attachShader(shaderProgram, fragmentShader);
			gl.linkProgram(shaderProgram);

			// If creating the shader program failed, alert
			if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
				alert("Unable to initialize the shader program.");
			}

			gl.useProgram(shaderProgram);

			shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
			gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

			shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
			gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

			shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
			shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
			shaderProgram.uNormalMatrix = gl.getUniformLocation(shaderProgram, "uNormalMatrix");

			shaderProgram.ambientLight = gl.getUniformLocation(shaderProgram, "ambientLight");
		}

		function getShader(gl, id) {
			var shaderScript = document.getElementById(id);
			if (!shaderScript) {
				return null;
			}

			var str = "";
			var k = shaderScript.firstChild;
			while (k) {
				if (k.nodeType == 3)
					str += k.textContent;
				k = k.nextSibling;
			}

			var shader;
			if (shaderScript.type == "x-shader/x-fragment") {
				shader = gl.createShader(gl.FRAGMENT_SHADER);
			} else if (shaderScript.type == "x-shader/x-vertex") {
				shader = gl.createShader(gl.VERTEX_SHADER);
			} else {
				return null;
			}

			gl.shaderSource(shader, str);
			gl.compileShader(shader);

			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				alert(gl.getShaderInfoLog(shader));
				return null;
			}

			return shader;
		}

		var mvMatrix = mat4.create();
		var pMatrix = mat4.create();

		function setMatrixUniforms() {
			gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
			gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);

			var normalMatrix = mat4.inverse(mvMatrix);
			normalMatrix = mat4.transpose(normalMatrix);
			gl.uniformMatrix4fv(shaderProgram.uNormalMatrix, false, normalMatrix);
		}

	</script>

	<!-- メインJavaScriptプログラム -->
	<script th:inline="javascript">
        var content = [[@{model/slime.mod}]];
		var model = null;                 // 読み込んだmodelファイル
																	   
		var autoRotate = true;            // 自動回転フラグ
		var angle = 0.3;                  // 回転度(0 ～ PI * 2)
		var lastMousePos = 0;             // 最後マウスが移動した場所（Xのみ）
																	   
		var currentFps = 0;               // 現在のFPS数
		var lastFtpUpdate = new Date();   // 最後FPSを更新した時間

		function initScene() {
			gl.viewport(0, 0, canvas.width, canvas.height);
			gl.clearColor(0.0, 0.0, 0.0, 1.0);

			// 深さテストを有効に設定
			gl.enable(gl.DEPTH_TEST);
			gl.depthFunc(gl.LEQUAL);
		}
		
		// 動画のフレーム処理
		function frame() {

			// 自動回転
			if (autoRotate) {
				angle += 0.01;
				if (angle > Math.PI * 2) angle -= Math.PI * 2;
			}

			drawScene();

			// FPS更新
			var now = new Date();
			if (lastFtpUpdate.getSeconds() != now.getSeconds()) {
				this.lastFtpUpdate = now;
				document.getElementById('msg').innerText = this.currentFps + " fps";
				this.currentFps = 1;
			} else {
				this.currentFps++;
			}
		}

		// 描画処理
		function drawScene() {

			// 動画呼び出し要請（frameが自動的に再度呼び出される）
			requestAnimationFrame(frame);

			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			// 投影行列初期化
			mat4.perspective(45, canvas.width / canvas.height, 0.1, 10.0, pMatrix);
			mat4.translate(pMatrix, [-0.0, -0.4, 0]);

			// グローバルオブジェクト変換行列初期化
			mat4.identity(mvMatrix);
			mat4.translate(mvMatrix, [0.0, 0.0, -1.6]);
			mat4.rotateY(mvMatrix, angle);

			// Modelファイルのオブジェクトを画面に出力
			drawModel(model);
		}

		window.onload = function () {
			modelManager.loadModel(content, function (model) {

				// WebGL初期化処理
				start();

				// modelの色を設定する
				model.color = [0.3, 0.3, 0.3, 1.0];

				// WebGLのバッファーにBindする
				bindModelBuffer(model);

				// modelオブジェクトをグローバル変数に設定
				window.model = model;

				// 描画開始
				drawScene();
			});
		};

		var canvas = document.getElementById('glcanvas');

		canvas.onmousedown = function (e) {
			autoRotate = false;
			lastMousePos = e.x;
		};

		canvas.onmousemove = function (e) {
			if (!autoRotate) {
				angle += (e.x - lastMousePos) / 50;
				lastMousePos = e.x;
			}
		};

		canvas.onmouseup = function (e) {
			autoRotate = true;
		};
		
	</script>

</body>
</html>
